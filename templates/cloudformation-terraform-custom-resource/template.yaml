---
AWSTemplateFormatVersion: "2010-09-09"

Resources:
  TerraFormExecuteFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import boto3
          import time
          import json
          import cfnresponse
          import subprocess
          import os

          def handler(event, context):
              print("Received event: " + json.dumps(event, indent=2))

              terraform_working_directory = '/tmp/terraform_files'

              # TODO: sha check
              subprocess.check_output('curl -o /tmp/terraform.zip https://releases.hashicorp.com/terraform/0.10.0/terraform_0.10.0_linux_amd64.zip', shell=True)
              subprocess.check_output('unzip -o -d /tmp /tmp/terraform.zip', shell=True)
              #print(subprocess.check_output('/tmp/terraform version', shell=True))

              if event['RequestType'] == 'Delete':
                  cfnresponse.send(event=event, context=context, responseStatus=cfnresponse.SUCCESS, responseData={}, physicalResourceId=event['LogicalResourceId'])
                  return

              # write terraform file
              os.makedirs(terraform_working_directory, exist_ok=True)
              open(os.path.join(terraform_working_directory, 'terraform.tf'), 'w').write(event['ResourceProperties']['Terraform'])

              try:
                subprocess.check_output('/tmp/terraform init', shell=True, cwd=terraform_working_directory)
                print(subprocess.check_output('/tmp/terraform apply', stderr=subprocess.STDOUT, shell=True, cwd=terraform_working_directory))

                terraform_outputs = json.loads(subprocess.check_output('/tmp/terraform output -json', stderr=subprocess.STDOUT, shell=True, cwd=terraform_working_directory))
                response_data = {key: value['value'] for key, value in terraform_outputs.items()}

                cfnresponse.send(event=event, context=context, responseStatus=cfnresponse.SUCCESS, responseData=response_data, physicalResourceId=event['LogicalResourceId'])

              except subprocess.CalledProcessError as exc:
                print("Status : FAILED", exc.returncode, exc.output)
                # TODO: add response data
                cfnresponse.send(event=event, context=context, responseStatus=cfnresponse.FAILED, responseData={}, physicalResourceId=event['LogicalResourceId'])
                return


      Handler: index.handler
      Runtime: python3.6
      Timeout: 300
      Role: !GetAtt TerraFormExecuteFunctionRole.Arn

  TerraFormStateStorage:
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled

  TerraFormExecuteFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
      - PolicyName: AllowWriteAndReadTerraformStateStorage
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - s3:Put*
            - s3:Get*
            - s3:List*
            Resource:
            - !GetAtt TerraFormStateStorage.Arn
            - !Sub '${TerraFormStateStorage.Arn}/*'
  TerraformExecutionPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: AllowCloudFrontAccess
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
            - cloudfront:*
            Resource: '*'
      Roles:
      - !Ref TerraFormExecuteFunctionRole

  TerraFormCustomResource:
    DependsOn: TerraFormExecuteFunction
    Type: Custom::TerraFormExecute
    Properties:
      ServiceToken: !GetAtt TerraFormExecuteFunction.Arn
      Terraform: !Sub |
        terraform {
          backend "s3" {
            bucket = "${TerraFormStateStorage}"
            key    = "terraform.tfstate"
            region = "${AWS::Region}"
          }
        }

        resource "aws_cloudfront_origin_access_identity" "origin_access_identity" {
          comment = "I am a resource managed by Terraform!"
        }

        output "cloudfront_oia_arn" {
          value = "${!aws_cloudfront_origin_access_identity.origin_access_identity.iam_arn}"
        }

        output "cloudfront_oia_path" {
          value = "${!aws_cloudfront_origin_access_identity.origin_access_identity.cloudfront_access_identity_path}"
        }

  ContentCdn:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
        - DomainName: !GetAtt ContentBucket.DomainName
          Id: S3Origin
          S3OriginConfig:
            OriginAccessIdentity: !GetAtt TerraFormCustomResource.cloudfront_oia_path
        DefaultCacheBehavior:
          ForwardedValues:
            QueryString: false
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
        Enabled: true
        ViewerCertificate:
          CloudFrontDefaultCertificate: true

  ContentBucket:
    Type: AWS::S3::Bucket

  ContentBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ContentBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          Effect: Allow
          Principal:
            AWS: !GetAtt TerraFormCustomResource.cloudfront_oia_arn
          Action: s3:GetObject
          Resource:
          - !Sub '${ContentBucket.Arn}/*'

  CdnViewerRequestFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          'use strict';

          let content = `
          <\!DOCTYPE html>
          <html lang="en">
            <head>
              <meta charset="utf-8">
              <title>Simple Lambda@Edge Static Content Response</title>
            </head>
            <body>
              <p>Hello from Lambda@Edge!</p>
            </body>
          </html>
          `;

          exports.handler = (event, context, callback) => {
              const response = {
                  status: '401',
                  statusDescription: 'Unauthorized',
                  headers: {
                      'www-authenticate': [{
                          key: 'WWW-Authenticate',
                          value: 'Basic realm="Lambda@Edge ist 1 nices CDN vong programmierbarkeit her."'
                      }],
                      'content-type': [{
                          key: 'Content-Type',
                          value: 'text/html'
                      }],
                      'content-encoding': [{
                          key: 'Content-Encoding',
                          value: 'UTF-8'
                      }],
                  },
                  body: content,
              };
              callback(null, response);
          };

      Handler: index.handler
      Runtime: nodejs6.10
      Timeout: 1
      MemorySize: 128
      Role: !GetAtt CdnViewerRequestFunctionRole.Arn

  CdnViewerRequestFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
            - edgelambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

Outputs:
  Test:
    Description: test
    Value: !GetAtt TerraFormCustomResource.cloudfront_oia_path
